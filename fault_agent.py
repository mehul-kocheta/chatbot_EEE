import numpy as np
import json
from groq import Groq
from dotenv import load_dotenv
from fault_analysis_matlab import get_fault_analysis_matlab
import os

load_dotenv()

client = Groq()
MODEL = "openai/gpt-oss-120b"

def run_conversation(user_prompt):
    # Initialize the conversation with system and user messages
    messages=[
        {
            "role": "system",
            "content": "You are a power system fault analysis assistant. Use the get_fault_analysis_matlab function to compute post-fault conditions given the positive sequence Ybus, Zbus matrices, pre-fault voltages and fault bus location. Parse the user's input into the required structured format for the tool call. At the end add a disclaimer that it's generated by LLM and might not be correct so take it with a pinch of salt."
        },
        {
            "role": "user",
            "content": user_prompt,
        }
    ]
    
    # Define the available tools for our model to use
    tools = [
        {
            "type": "function",
            "function": {
                "name": "get_fault_analysis_matlab",
                "description": "Calculate post-fault voltages and currents for a three-phase bolted fault",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "bus_matrix_np": {
                            "type": "array",
                            "description": "The positive sequence matrix (either Zbus or Ybus) as a list of lists of objects with real and imag parts",
                            "items": {
                                "type": "array",
                                "items": {
                                    "type": "object",
                                    "properties": {
                                        "real": {
                                            "type": "number"
                                        },
                                        "imag": {
                                            "type": "number"
                                        }
                                    },
                                    "required": ["real", "imag"]
                                }
                            }
                        },
                        "is_zbus": {
                            "type": "boolean",
                            "description": "True if bus_matrix is Zbus, False if it is Ybus"
                        },
                        "v_pre_np": {
                            "type": "array",
                            "description": "The pre-fault voltage vector as a list of objects with real and imag parts",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "real": {
                                        "type": "number"
                                    },
                                    "imag": {
                                        "type": "number"
                                    }
                                },
                                "required": ["real", "imag"]
                            }
                        },
                        "fault_bus_py": {
                            "type": "integer",
                            "description": "The 0-based index of the bus where the fault occurs"
                        }
                    },
                    "required": ["bus_matrix_np", "is_zbus", "v_pre_np", "fault_bus_py"]
                }
            }
        }
    ]

    # Make the initial API call to Groq
    response = client.chat.completions.create(
        model=MODEL,
        messages=messages,
        stream=False,
        tools=tools,
        tool_choice="auto",
        max_tokens=8100
    )

    # Extract the response and any tool calls
    response_message = response.choices[0].message
    tool_calls = response_message.tool_calls

    if tool_calls:
        # Define helper functions to parse structured args to numpy arrays
        def parse_complex_dict(d):
            return complex(d['real'], d['imag'])
        
        def parse_vector(vec):
            return np.array([parse_complex_dict(item) for item in vec], dtype=complex)
        
        def parse_matrix(mat):
            return np.array([[parse_complex_dict(item) for item in row] for row in mat], dtype=complex)

        # Define available tools
        available_functions = {
            "get_fault_analysis_matlab": get_fault_analysis_matlab,
        }

        # Add the LLM's response to conversation
        messages.append(response_message)

        # Process each tool call
        for tool_call in tool_calls:
            function_name = tool_call.function.name
            function_to_call = available_functions[function_name]
            function_args = json.loads(tool_call.function.arguments)
            
            # Parse arguments
            bus_matrix_parsed = parse_matrix(function_args.get("bus_matrix_np"))
            is_zbus = function_args.get("is_zbus")
            v_pre_parsed = parse_vector(function_args.get("v_pre_np"))
            fault_bus = function_args.get("fault_bus_py")

            # Call the tool and get response
            v_post, i_fault, i_post_inject = function_to_call(
                bus_matrix_np=bus_matrix_parsed,
                is_zbus=is_zbus,
                v_pre_np=v_pre_parsed,
                fault_bus_py=fault_bus
            )

            # Format the response as a string
            response_str = (
                f"Post-fault analysis results:\n"
                f"1. Post-fault voltages (pu): {v_post}\n"
                f"2. Fault current (pu): {i_fault}\n"
                f"3. Post-fault current injections (pu): {i_post_inject}"
            )

            # Add tool response to conversation
            messages.append(
                {
                    "tool_call_id": tool_call.id,
                    "role": "tool",
                    "name": function_name,
                    "content": response_str,
                }
            )

        # Make second API call with updated conversation
        second_response = client.chat.completions.create(
            model=MODEL,
            messages=messages
        )
        
        # Return final response
        return second_response.choices[0].message.content
    else:
        return response_message.content


def run_fault_agent(user_prompt):
    """
    Wrapper function for orchestrator compatibility
    """
    return run_conversation(user_prompt)