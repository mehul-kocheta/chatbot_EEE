import numpy as np
import json
from groq import Groq
from dotenv import load_dotenv
import os
from gs_agent import run_gs_agent
from loss_agent import run_loss_agent
from fault_agent import run_fault_agent

load_dotenv()

client = Groq()
MODEL = "openai/gpt-oss-120b"

def run_conversation(user_prompt):
    # Initialize the conversation with system and user messages
    messages=[
        {
            "role": "system",
            "content": """You are a comprehensive power system analysis assistant. You can:
            1. Solve power flow using Gauss-Seidel method to find bus voltages
            2. Calculate total system losses after adding new loads
            3. Find after fault voltages and currents for 3 phase bolted faults
            
            Parse the user's input and determine which tool(s) to use. You can use both tools in sequence if needed.
            For example, if user wants to know system losses after adding a new load, first solve power flow using
            Gauss-Seidel, then use those voltages to calculate losses.
            
            or if user wants to find after fault voltages/currents, first solve power flow to get pre-fault voltages,
            then use those voltages for fault analysis.
            
            Output your answer in pure markdown format, no latex equations.
            
            At the end add a disclaimer that it's generated by LLM and might not be correct so take it with a pinch of salt."""
        },
        {
            "role": "user",
            "content": user_prompt,
        }
    ]
    
    # Define the available tools for our model to use
    tools = [
        {
            "type": "function",
            "function": {
                "name": "run_power_flow_agent",
                "description": "Use Gauss-Seidel agent to solve power flow and get bus voltages",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "query": {
                            "type": "string",
                            "description": "The query for power flow solution in the format 'Ybus: [[...]], P: [...]'"
                        }
                    },
                    "required": ["query"]
                }
            }
        },
        {
            "type": "function",
            "function": {
                "name": "run_loss_agent",
                "description": "Use loss calculation agent to compute system losses",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "query": {
                            "type": "string",
                            "description": "The query for loss calculation in the format 'Ybus: [[...]], V: [...], new load: ..., at bus ...'"
                        }
                    },
                    "required": ["query"]
                }
            }
        },
        {
            "type": "function",
            "function": {
                "name": "run_bolted_fault_agent",
                "description": "Use ybus/zbus and pre-fault voltages to compute post-fault voltages and currents for a three-phase bolted fault",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "query": {
                            "type": "string",
                            "description": "The query for fault analysis in the format 'Ybus/Zbus: [[...]], is_zbus: true/false, V_pre: [...], fault at bus ...'"
                        }
                    },
                    "required": ["query"]
                }
            }
        }
    ]

    # Define available tools mapping
    available_functions = {
        "run_power_flow_agent": run_gs_agent,
        "run_loss_agent": run_loss_agent,
        "run_bolted_fault_agent": run_fault_agent
    }

    # Iterative loop to handle multiple rounds of tool calls
    max_iterations = 10  # Safety limit to prevent infinite loops
    iteration = 0
    
    while iteration < max_iterations:
        # Make API call to Groq
        response = client.chat.completions.create(
            model=MODEL,
            messages=messages,
            stream=False,
            tools=tools,
            tool_choice="auto",
            max_tokens=8100
        )

        # Extract the response and any tool calls
        response_message = response.choices[0].message
        tool_calls = response_message.tool_calls

        # Add the LLM's response to conversation
        messages.append(response_message)

        # If there are no tool calls, return the final response
        if not tool_calls:
            return response_message.content

        # Process each tool call
        for tool_call in tool_calls:
            function_name = tool_call.function.name
            function_to_call = available_functions[function_name]
            function_args = json.loads(tool_call.function.arguments)
            
            # Call the appropriate agent with the query
            function_response = function_to_call(function_args["query"])
            print(function_name, function_response)
            # Add tool response to conversation
            messages.append(
                {
                    "tool_call_id": tool_call.id,
                    "role": "tool",
                    "name": function_name,
                    "content": function_response,
                }
            )
        
        iteration += 1
    
    # If we've reached max iterations, return the last response
    return response_message.content if response_message.content else "Maximum iterations reached. Please try a simpler query."
    
    
def run_power_flow_agent(user_prompt):
    return run_conversation(user_prompt)