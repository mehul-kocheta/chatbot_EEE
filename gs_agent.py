import numpy as np
import json
# Assume the following imports and setups are done:
from groq import Groq
from dotenv import load_dotenv
import os

load_dotenv()

client = Groq()
MODEL = "openai/gpt-oss-120b"  # or the appropriate model name

def gauss_seidel(Ybus, P, V_init=None, tol=1e-4, max_iter=100):
    n = len(P)
    if V_init is None:
        V = np.ones(n, dtype=complex)
    else:
        V = V_init.copy()

    for _ in range(max_iter):
        V_prev = V.copy()
        for i in range(n):
            sigma = sum(Ybus[i][j] * V[j] for j in range(n) if j != i)
            V[i] = (P[i] - sigma) / Ybus[i][i]
        if np.max(np.abs(V - V_prev)) < tol:
            break
    return V

def run_conversation(user_prompt):
    # Initialize the conversation with system and user messages
    messages=[
        {
            "role": "system",
            "content": "You are a power flow assistant. Use the gauss_seidel function to compute bus voltages given the Ybus matrix and power injections P. Parse the user's input into the required structured format for the tool call. At the end add a disclaimer that it's generated by LLM and might not be correct so take it with a pinch of salt (exectly like this)"
        },
        {
            "role": "user",
            "content": user_prompt,
        }
    ]
    # Define the available tools (i.e. functions) for our model to use
    tools = [
        {
            "type": "function",
            "function": {
                "name": "gauss_seidel",
                "description": "Solve for bus voltages using the Gauss-Seidel method",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "Ybus": {
                            "type": "array",
                            "description": "The admittance matrix Ybus as a list of lists of objects with real and imag parts",
                            "items": {
                                "type": "array",
                                "items": {
                                    "type": "object",
                                    "properties": {
                                        "real": {
                                            "type": "number"
                                        },
                                        "imag": {
                                            "type": "number"
                                        }
                                    },
                                    "required": ["real", "imag"]
                                }
                            }
                        },
                        "P": {
                            "type": "array",
                            "description": "The power injections P (can be complex) as a list of objects with real and imag parts",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "real": {
                                        "type": "number"
                                    },
                                    "imag": {
                                        "type": "number"
                                    }
                                },
                                "required": ["real", "imag"]
                            }
                        },
                        "V_init": {
                            "type": "array",
                            "description": "Optional initial voltage guesses as a list of objects with real and imag parts",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "real": {
                                        "type": "number"
                                    },
                                    "imag": {
                                        "type": "number"
                                    }
                                },
                                "required": ["real", "imag"]
                            }
                        },
                        "tol": {
                            "type": "number",
                            "description": "Tolerance for convergence"
                        },
                        "max_iter": {
                            "type": "integer",
                            "description": "Maximum number of iterations"
                        }
                    },
                    "required": ["Ybus", "P"]
                }
            }
        }
    ]
    # Make the initial API call to Groq
    response = client.chat.completions.create(
        model=MODEL, # LLM to use
        messages=messages, # Conversation history
        stream=False,
        tools=tools, # Available tools (i.e. functions) for our LLM to use
        tool_choice="auto", # Let our LLM decide when to use tools
        max_tokens=8100 # Maximum number of tokens to allow in our response
    )
    # Extract the response and any tool call responses
    response_message = response.choices[0].message
    tool_calls = response_message.tool_calls
    if tool_calls:
        # Define helper functions to parse structured args to complex numpy arrays
        def parse_complex_dict(d):
            return complex(d['real'], d['imag'])
        
        def parse_vector(vec):
            if not vec:
                return None
            return np.array([parse_complex_dict(item) for item in vec], dtype=complex)
        
        def parse_matrix(mat):
            return np.array([[parse_complex_dict(item) for item in row] for row in mat], dtype=complex)
        
        # Define the available tools that can be called by the LLM
        available_functions = {
            "gauss_seidel": gauss_seidel,
        }
        # Add the LLM's response to the conversation
        messages.append(response_message)

        # Process each tool call
        for tool_call in tool_calls:
            function_name = tool_call.function.name
            function_to_call = available_functions[function_name]
            function_args = json.loads(tool_call.function.arguments)
            # Parse arguments
            ybus_parsed = parse_matrix(function_args.get("Ybus"))
            p_parsed = parse_vector(function_args.get("P"))
            v_init_parsed = parse_vector(function_args.get("V_init"))
            tol = function_args.get("tol", 1e-4)
            max_iter = function_args.get("max_iter", 100)
            # Call the tool and get the response
            function_response = function_to_call(
                Ybus=ybus_parsed,
                P=p_parsed,
                V_init=v_init_parsed,
                tol=tol,
                max_iter=max_iter
            )
            # Convert response to string
            function_response = np.array2string(function_response, precision=4, suppress_small=True)
            # Add the tool response to the conversation
            messages.append(
                {
                    "tool_call_id": tool_call.id, 
                    "role": "tool", # Indicates this message is from tool use
                    "name": function_name,
                    "content": function_response,
                }
            )
        # Make a second API call with the updated conversation
        second_response = client.chat.completions.create(
            model=MODEL,
            messages=messages
        )
        # Return the final response
        return second_response.choices[0].message.content
    else:
        return response_message.content

def run_power_flow_agent(user_prompt):
    """
    Wrapper function for orchestrator compatibility
    """
    return run_conversation(user_prompt)